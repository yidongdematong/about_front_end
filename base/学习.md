## 箭头函数

1、介绍
箭头函数 es6 标准新增的一种新的函数：arrow function (箭头函数)，叫箭头函数的原因就是因为它的使用方法就是一个箭头。

```
y=>y+y
```

2、基本用法
上面的语句相当于

```
function (y){
return y+y
}
```

箭头函数在语法上可以认为是匿名函数的一种缩写，在不同的情况下箭头函数的用法稍有不同，如下

```
//一.当函数只有一个参数时，可以不用括号，如1.中所示
//二.当函数有多个参数时，需用括号括住参数，如
(x+y)=>x+y
相当于
function (x,y){
    return x+y
}
//三.当函数内部只有一条或没有语句时，花括号可以省略,如果这条语句还是return语句，那么return也可以一并省略，如1.中所示
//四.当函数内部有多条语句时，花括号不可省略，如
x=>{
x>100?x='输入的值大于100':x='输入的值小于100'
console.log(x)
}

//五.无参数的匿名函数
()=>{语句}
```

### 注意事项

1. 如果单条语句 return 的是一个对象，那么在使用箭头函数时就不能省略花括号，这样做会引起语法冲突，因为 js 引擎会误将对象的花括号认作函数的花括号，举个例子

```
x=>{age:x}//错误
x=>{{age:x}}//正确
x=>({age:x})//正确
```

2. this
   箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的 this 是词法作用域，由上下文确定,这种规则解决了许多 es5 中关于 this 指向不同带来的问题（比如嵌套函数或者对象中需要用临时变量来搬运 this，或者使用 bind),现在，箭头函数完全修复了 this 的指向，this 总是指向词法作用域，也就是外层调用者 obj，如下

```
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = () => new Date().getFullYear() - this.birth;
        // 此处this指向obj对象，es5中会指向windows
        return fn();
    }
};
obj.getAge(); // 25

```

由于 this 在箭头函数中已经按照词法作用域绑定了，所以，用 call()或者 apply()调用箭头函数时，无法对 this 进行绑定，即传入的第一个参数被忽略：

```
var obj = {
    birth: 1990,
    getAge: function (year) {
        var b = this.birth; // 1990
        var fn = (y) => y - this.birth; // this.birth仍是1990
        return fn.call({birth:2000}, year);
    }
};
obj.getAge(2015); // 25

```

## 声明变量

- let

声明的变量只有在 let 所在的代码块内有效

- var

声明全局变量

```
{
  let a=10;
  var b=1;
}
a // ReferenceError: a is not defined.
b // 1
```

上面代码在代码块之中，分别用 let 和 var 声明了两个变量。然后在代码块之外调用这两个变量，结果 let 声明的变量报错，var 声明的变量返回了正确的值。这表明，let 声明的变量只在它所在的代码块有效。
for 循环的计数器，就很合适使用 let 命令。

```
for (let i = 0; i < 10; i++) {
  // ...
}

console.log(i);
// ReferenceError: i is not defined
```

上面代码中，计数器 i 只在 for 循环体内有效，在循环体外引用就会报错。

下面的代码如果使用 var，最后输出的是 10。

```
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10
```

上面代码中，变量 i 是 var 命令声明的，在全局范围内都有效，所以全局只有一个变量 i。每一次循环，变量 i 的值都会发生改变，而循环内被赋给数组 a 的函数内部的 console.log(i)，里面的 i 指向的就是全局的 i。也就是说，所有数组 a 的成员里面的 i，指向的都是同一个 i，导致运行时输出的是最后一轮的 i 的值，也就是 10。

如果使用 let，声明的变量仅在块级作用域内有效，最后输出的是 6。

```
var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
```

上面代码中，变量 i 是 let 声明的，当前的 i 只在本轮循环有效，所以每一次循环的 i 其实都是一个新的变量，所以最后输出的是 6。你可能会问，如果每一轮循环的变量 i 都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量 i 时，就在上一轮循环的基础上进行计算。

另外，for 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。

```
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
```

上面代码正确运行，输出了 3 次 abc。这表明函数内部的变量 i 与循环变量 i 不在同一个作用域，有各自单独的作用域（同一个作用域不可使用 let 重复声明同一个变量）。

# \*\*\*关于面的结论只限定在 js 中，起码 java 中是没有这种 bug 的，是 bug，明显的语法不严谨，所以不是看不起 js，是它自身的局限 \*\*\*

- constant

声明一个只读的常量。一旦声明，常量的值就不能改变。

const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。

## globalThis 对象

JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。

- 浏览器里面，顶层对象是 window，但 Node 和 Web Worker 没有 window。

- 浏览器和 Web Worker 里面，self 也指向顶层对象，但是 Node 没有 self。

- Node 里面，顶层对象是 global，但其他环境都不支持。
